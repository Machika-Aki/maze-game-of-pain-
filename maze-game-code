import pygame
import time
import random
from collections import deque

# Initialize Pygame
pygame.init()

# Set up the display
screen = pygame.display.set_mode((400, 400))
pygame.display.set_caption("Maze Game")

# Define colors
WHITE = (255, 255, 255)
GREY = (183, 176, 187)
PURPLE = (174, 74, 241)
GREEN = (103, 229, 156)
RED = (241, 74, 74)

# Global variables
maze = None
player_pos = None
goal_pos = None
enemy_pos = None
player_first_move_time = None
last_ability_use_time = 0
ability_active = False
last_block_ability_use_time = 0
placed_blocks = []
last_enemy_move_time = 0


def generate_maze(width, height):
    maze = [['W' for _ in range(width)] for _ in range(height)]

    def carve_passages_from(cx, cy, maze):
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        random.shuffle(directions)
        for direction in directions:
            nx, ny = cx + direction[0] * 2, cy + direction[1] * 2
            if 0 <= nx < width and 0 <= ny < height and maze[ny][nx] == 'W':
                maze[cy + direction[1]][cx + direction[0]] = 'E'
                maze[ny][nx] = 'E'
                carve_passages_from(nx, ny, maze)

    maze[1][1] = 'E'
    carve_passages_from(1, 1, maze)
    maze[height - 2][width - 2] = 'E'

    return maze


def bfs(start, goal, maze):
    queue = deque([start])
    visited = set()
    visited.add(tuple(start))
    parent = {tuple(start): None}

    while queue:
        current = queue.popleft()
        if current == goal:
            path = []
            while current:
                path.append(current)
                current = parent[tuple(current)]
            return path[::-1]

        for direction in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
            neighbor = [current[0] + direction[0], current[1] + direction[1]]
            if (0 <= neighbor[0] < len(maze[0]) and 0 <= neighbor[1] < len(maze) and
                    maze[neighbor[1]][neighbor[0]] == 'E' and tuple(neighbor) not in visited):
                queue.append(neighbor)
                visited.add(tuple(neighbor))
                parent[tuple(neighbor)] = current
    return []


def reset_game():
    global maze, player_pos, goal_pos, enemy_pos, player_first_move_time, last_ability_use_time, ability_active, last_block_ability_use_time, placed_blocks, last_enemy_move_time
    maze = generate_maze(20, 20)
    player_pos = [1, 1]
    goal_pos = [len(maze[0]) - 2, len(maze) - 2]
    enemy_pos = [1, 1]
    player_first_move_time = None
    last_ability_use_time = 0
    ability_active = False
    last_block_ability_use_time = 0
    placed_blocks = []
    last_enemy_move_time = 0


# Initial game setup
reset_game()

# Main game loop
running = True
last_move_time = time.time()
move_delay = 1 / 20  # 5 moves per second

while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
    keys = pygame.key.get_pressed()

    # Simplified movement logic
    current_time = time.time()
    if current_time - last_move_time >= move_delay:
        if keys[pygame.K_r] and current_time - last_ability_use_time >= 2.5:
            ability_active = True
            last_ability_use_time = current_time

        if keys[pygame.K_LEFT]:
            new_pos = [player_pos[0] - 1, player_pos[1]]
            if new_pos[0] >= 0 and (maze[new_pos[1]][new_pos[0]] == 'E' or ability_active):
                player_pos = new_pos
        if keys[pygame.K_RIGHT]:
            new_pos = [player_pos[0] + 1, player_pos[1]]
            if new_pos[0] < len(maze[0]) and (maze[new_pos[1]][new_pos[0]] == 'E' or ability_active):
                player_pos = new_pos
        if keys[pygame.K_UP]:
            new_pos = [player_pos[0], player_pos[1] - 1]
            if new_pos[1] >= 0 and (maze[new_pos[1]][new_pos[0]] == 'E' or ability_active):
                player_pos = new_pos
        if keys[pygame.K_DOWN]:
            new_pos = [player_pos[0], player_pos[1] + 1]
            if new_pos[1] < len(maze) and (maze[new_pos[1]][new_pos[0]] == 'E' or ability_active):
                player_pos = new_pos

        if player_first_move_time is None and (
                keys[pygame.K_LEFT] or keys[pygame.K_RIGHT] or keys[pygame.K_UP] or keys[pygame.K_DOWN]):
            player_first_move_time = current_time

        last_move_time = current_time

    # Enemy movement
    if player_first_move_time and current_time - last_enemy_move_time >= 10:
        path = bfs(enemy_pos, player_pos, maze)
        if len(path) > 1:
            enemy_pos = path[1]
            last_enemy_move_time = current_time

    # Game state checks
    if player_pos == goal_pos or player_pos == enemy_pos:
        reset_game()

    # Drawing
    screen.fill(WHITE)
    for y, row in enumerate(maze):
        for x, cell in enumerate(row):
            if cell == 'W':
                pygame.draw.rect(screen, GREY, (x * 20, y * 20, 20, 20))
            elif cell == 'E':
                pygame.draw.rect(screen, WHITE, (x * 20, y * 20, 20, 20))

    pygame.draw.rect(screen, GREEN, (goal_pos[0] * 20, goal_pos[1] * 20, 20, 20))
    pygame.draw.rect(screen, PURPLE, (player_pos[0] * 20, player_pos[1] * 20, 20, 20))
    pygame.draw.rect(screen, RED, (enemy_pos[0] * 20, enemy_pos[1] * 20, 20, 20))

    pygame.display.flip()
    pygame.time.Clock().tick(30)

pygame.quit()
